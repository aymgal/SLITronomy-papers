__author__ = 'aymgal'

import numpy as np
from lenstronomy.Util.param_util import phi_q2_ellipticity

# here we set the global parameters used for the simulation of mock data (HST and E-ELT)


##### COSMO SETTINGS #####
Om0 = 0.3
H0 = 70.0

##### LENS MODEL SETTINGS #####
z_lens = 0.3

# main deflector
sigma_v = 260  # km/s
ra_lens, dec_lens = 0, 0
lens_PA, lens_q = 0, 0.8
lens_e1, lens_e2 = phi_q2_ellipticity(lens_PA, lens_q)

# extrenal shear
gamma_ext, psi_ext = 0.03, np.pi/4


##### FIELD OF VIEW SETTINGS #####
cutout_size = 8  # arcsec

##### MASK SETTINGS #####
mask_outer_radius = 3.8
mask_inner_radius = None


##### SOURCE SETTINGS #####
z_source = 1.2

# single galaxy
galaxy_name = 'NGC3982'
ra_source, dec_source = 0.05, 0.05 #0, 0.08
#ra_source2, dec_source2 = ra_source-0.2, dec_source+0.4
mag_source = 22

# galaxy group
pos_source_list = [(0.05, 0.05), (-0.8, -0.6), (0.3, 0.8)]
mag_source_list = [22, 22, 23]
galaxy_name_list = ['NGC3982', 'ESO498G5', 'NGC3259']


##### INSTRUMENT SETTINGS #####

#**HST data**
#Instrument and observational setting inspired by J1537-3010 F160W science frame (after drizzling) and the WFC3/IR Exposure Time Calculator, for 4x500s exposures before drizzling.


#**E-ELT data**
#Instrument and observational setting inspired by Meng, Treu et al. 2015 (but those were for another very large telescope, the TMT) and Deep et al. 2011 (gives some limiting mag at a given exposure time), and the ELT Exposure Time Calculator for H band on the MICADO instrument (http://www.eso.org/observing/etc/bin/gen/form?INS.NAME=ELT+INS.MODE=swimaging).

def get_simulation_kwargs(instrument_type, psf_type, psf_kernel):
    if instrument_type == 'HST':
        # HST WCF3 F160W band
        kwargs_simulation = {
            # instrument-related
            #'read_noise': 80,  # std of noise generated by read-out (in units of electrons)
            'ccd_gain': 2.5,  # electrons/ADU (analog-to-digital unit). A gain of 8 means that the camera digitizes the CCD signal so that each ADU corresponds to 8 photoelectrons.
            'pixel_scale': 0.08,  # scale (in arcseonds) of pixels

            # observation-related
            #'sky_brightness': 21.7,  # sky brightness (in magnitude per square arcseconds)
            'exposure_time': 500,  # exposure time per image (in seconds)
            'magnitude_zero_point': 28,  # magnitude in which 1 count per second per arcsecond square is registered (in ADU's)
            'num_exposures': 4,  # number of exposures that are combined
            'data_count_unit': 'e-',  # 'ADU' or 'e-'. It was 'ADU' before some lenstronomy changes around july 2020

            # or instead of 'read_noise' + 'sky_brightness'
            'background_noise': 0.05,  #Â in units of data_count_unit

            'psf_type': psf_type,  # string, type of PSF ('GAUSSIAN' and 'PIXEL' supported)
            'kernel_point_source': psf_kernel  # 2d numpy array, model of PSF centered with odd number of pixels per axis (optional when psf_type='PIXEL' is chosen)
        }
        kwargs_numerics_simulation = {'supersampling_factor': 5}

    elif instrument_type == 'ELT':
        # ELT MICADO H band
        kwargs_simulation = {
            # instrument-related
            'read_noise': 3,  # std of noise generated by read-out (in units of electrons)
            'ccd_gain': 1,  # electrons/ADU (analog-to-digital unit). A gain of 8 means that the camera digitizes the CCD signal so that each ADU corresponds to 8 photoelectrons.
            'pixel_scale': 0.004,  # scale (in arcseonds) of pixels

            # observation-related
            'sky_brightness': 25,  # sky brightness (in magnitude per square arcseconds), depends on exposure time
            'exposure_time': 1200,  # exposure time per image (in seconds)
            'magnitude_zero_point': 34,  # magnitude in which 1 count per second per arcsecond square is registered (in ADU's)
            'num_exposures': 1,  # number of exposures that are combined
            'data_count_unit': 'e-',  # 'ADU' or 'e-'. It was 'ADU' before some lenstronomy changes around july 2020

            # or instead of 'read_noise' + 'sky_brightness'
            #'background_noise': 0.04,

            'psf_type': psf_type,  # string, type of PSF ('GAUSSIAN' and 'PIXEL' supported)
            'kernel_point_source': psf_kernel  # 2d numpy array, model of PSF centered with odd number of pixels per axis (optional when psf_type='PIXEL' is chosen)
        }
        kwargs_numerics_simulation = {'supersampling_factor': 1}
    
    return kwargs_simulation, kwargs_numerics_simulation
